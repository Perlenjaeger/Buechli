import os
import pickle
import re
import hashlib
from functools import wraps
from typing import Any, Callable
from util.utils import get_project_path


def normalize_query(query: str) -> str:
    """
    Normalizes a query string by removing punctuation and whitespace,
    and converting it to lowercase.

    Example:
        >>> normalize_query("ReAct ?")
        "react"
    """
    # Remove all punctuation
    normalized = re.sub(r"[^\w\s]", "", query)
    # Remove all whitespace
    normalized = re.sub(r"\s+", "", normalized)
    return normalized.lower()


def generate_cache_key(func: Callable[..., Any], args: tuple, kwargs: dict) -> str:  # type: ignore
    """
    Generates a cache key by combining the function name with a hash of the input parameters.

    If a 'query' parameter is present (or the first positional argument is a string),
    it normalizes and hashes that value. Otherwise, it serializes all arguments and
    computes a hash of them.

    MD5 is used because it produces a consistent, fixed-length hash quickly,
    which is sufficient for caching purposes (note: MD5 is not secure for cryptographic uses).
    """
    func_name = func.__name__

    # Check if there is a 'query' keyword argument, or if the first argument is a string.
    query_value = kwargs.get("query", None)  # type: ignore
    if query_value is None and args and isinstance(args[0], str):
        query_value = args[0]

    if query_value is not None:
        # Normalize the query and compute its MD5 hash
        normalized = normalize_query(str(query_value))  # type: ignore
        hash_part = hashlib.md5(normalized.encode()).hexdigest()
    else:
        # Serialize all arguments with pickle and compute an MD5 hash of them
        hash_part = hashlib.md5(pickle.dumps((args, kwargs))).hexdigest()

    return f"{func_name}_{hash_part}"


def debug_stub_store(func: Callable[..., Any]) -> Callable[..., Any]:
    """
    Decorator that caches the result of a function to disk.

    When the decorated function is called with the same parameters (even across different debug sessions),
    the cached result is loaded from disk instead of re-executing the function.

    The cache key is generated by combining the function name with an MD5 hash of the input parameters,
    ensuring that identical inputs always result in the same cached key.
    """

    @wraps(func)
    def wrapper(*args, **kwargs) -> Any:  # type: ignore
        print(f"Running {func.__name__}")

        cache_key = generate_cache_key(func, args, kwargs)
        result_path = os.path.join(
            get_project_path(), "debug_store", f"{cache_key}.bin"
        )

        if os.path.exists(result_path):
            print(f"Loading cached result for key: {cache_key}")
            with open(result_path, "rb") as f:
                return pickle.load(f)

        print(f"Computing new result for key: {cache_key}")
        result = func(*args, **kwargs)

        os.makedirs(os.path.dirname(result_path), exist_ok=True)
        with open(result_path, "wb") as f:
            pickle.dump(result, f)

        return result

    return wrapper  # type: ignore
